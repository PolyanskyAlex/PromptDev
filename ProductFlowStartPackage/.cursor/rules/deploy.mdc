---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: false
---
{
  "context": "docker_deploy_execution",
  "description": "Правила безопасного, воспроизводимого и автоматизированного деплоя на базе контейнеров и принципов GitOps/DevSecOps.",
  "inherits": ".cursor/rules/_common_principles.mdc",

  "coreConcept": {
    "artifact": "Единственным артефактом для деплоя является неизменяемый, версионированный Docker-образ, хранящийся в приватном Container Registry.",
    "process": "CI (Code Integration) -> CD (Continuous Delivery/Deployment). CI отвечает за сборку и тестирование, CD — за развертывание."
  },

  "dockerfileBestPractices": {
    "multiStageBuilds": "Обязательно использовать multi-stage builds для разделения сборочного окружения и production-окружения. Это минимизирует размер и поверхность атаки финального образа.",
    "nonRootUser": "Контейнер должен запускаться от имени непривилегированного пользователя, созданного внутри Dockerfile (`USER appuser`).",
    "caching": "Оптимизировать порядок инструкций для максимального использования кеша слоев Docker (сначала `COPY package.json`, потом `npm install`, потом `COPY . .`).",
    "baseImage": "Использовать только официальные, минималистичные и проверенные базовые образы, предпочтительно `distroless` или `alpine`."
  },

  "cicdPipeline": {
    "trigger": "Пайплайн должен иметь разные сценарии для разных триггеров: `pull_request` (тесты, линтеры), `push` в `main` (сборка, пуш образа), создание `release` тега (деплой на production).",
    "securityInPipeline": [
      "SAST (Static Application Security Testing): Анализ исходного кода на уязвимости (например, SonarQube, CodeQL).",
      "SCA (Software Composition Analysis): Сканирование зависимостей на известные уязвимости (Snyk, Dependabot).",
      "Container Scanning: Сканирование Docker-образа на уязвимости после сборки (Trivy, Grype)."
    ],
    "deploymentTools": "Деплой должен осуществляться через системы управления конфигурацией или декларативные инструменты (Helm, Kustomize, Ansible, Terraform)."
  },

  "githubActionsInteraction": {
    "title": "Правила взаимодействия с GitHub Actions",
    "description": "Конкретные шаги для агента по работе с CI/CD пайплайнами в GitHub.",
    "workflowDiscovery": {
      "action": "Найди файлы воркфлоу в директории `.github/workflows/`. Основные файлы, на которые стоит обратить внимание: `ci.yml`, `deploy.yml`, `release.yml`."
    },
    "triggerAndMonitor": {
      "action": "Запусти воркфлоу (через `git push` или `gh workflow run`). Отслеживай его выполнение с помощью команды `gh run watch <run_id>` до завершения.",
      "requirement": "Не продолжай выполнение пайплайна, пока воркфлоу не завершится (успешно или с ошибкой)."
    },
    "logAnalysis": {
      "action": "В случае сбоя воркфлоу, немедленно скачай полные логи (`gh run view <run_id> --log`).",
      "searchKeywords": [
        "Ищи в логах ключевые слова: `Error`, `failed`, `exit code`, `npm ERR!`, `pytest: ... failed`, `denied`, `unauthorized`.",
        "Проанализируй контекст вокруг найденного ключевого слова, чтобы определить шаг, на котором произошел сбой (например, 'Run tests', 'Build Docker image', 'Deploy to Staging').",
        "Определи точную причину: ошибка компиляции, провалившийся тест, неверный креды, проблема с зависимостью, ошибка в скрипте деплоя."
      ]
    },
    "workflowModification": {
      "action": "Если причина сбоя находится в самом `.yml` файле воркфлоу (например, неверная команда или путь), исправь его в рамках задачи по багфиксингу.",
      "precaution": "Перед коммитом изменений в `.yml` файле, проверь его синтаксис локально."
    }
  },

  "environmentConfiguration": {
    "iac": "Инфраструктура (сети, базы данных, сервисы) должна описываться в коде (Infrastructure as Code) с помощью Terraform или аналогов.",
    "separation": "Полная изоляция окружений `dev`, `staging` и `production` (разные сети, базы данных, учетные записи).",
    "secrets": "Секреты должны централизованно управляться через Vault, AWS Secrets Manager, GCP Secret Manager и безопасно внедряться в среду выполнения во время запуска, а не сборки."
  },

  "monitoringAndLogging": {
    "logging": "Все приложения должны писать структурированные логи (JSON) в `stdout`/`stderr`. Каждый лог должен содержать `correlation_id` для трассировки запросов через несколько сервисов.",
    "healthChecks": "Реализовать два типа health-check эндпоинтов: `livenessProbe` (сервис жив?) и `readinessProbe` (сервис готов принимать трафик?).",
    "metrics": "Приложения должны экспортировать метрики в формате Prometheus (время ответа, частота ошибок, сатурация ресурсов) для сбора системой мониторинга."
  },

  "rollbackStrategy": {
    "primary": "Основная стратегия — автоматический откат на предыдущий стабильный тег Docker-образа в случае провала health-check'ов после деплоя.",
    "database": "Миграции базы данных должны быть обратно совместимыми или иметь явные скрипты отката."
  }
}